using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Exceptions;
using Noggog;

namespace MakeModsScrappable
{
    public class Program
    {
        static Lazy<ModsScrappableSettings> _lazySettings = null!;
        static ModsScrappableSettings Settings => _lazySettings.Value;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
                 .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _lazySettings)
                .SetTypicalOpen(GameRelease.Fallout4, "ScrappableMods.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            var processor = new ModsScrapProcessor(Settings, state);
            processor.Process();
        }

        internal class ModsScrapProcessor
        {
            private readonly ModsScrappableSettings settings;
            private readonly IPatcherState<IFallout4Mod, IFallout4ModGetter> state;

            private readonly SortedSet<FormKey> blackList = new(Comparer<FormKey>.Create((f1, f2) => f1.GetHashCode().CompareTo(f2.GetHashCode())));

            public ModsScrapProcessor(ModsScrappableSettings settings, IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
            {
                this.settings = settings;
                this.state = state;

                //blackList
                //blackList = settings.excludeList.Select(fLink => fLink.FormKey) ?? new List<FormKey>();
                foreach (var entry in settings.excludeList)
                {
                    if (!blackList.Contains(entry.FormKey))
                    {
                        blackList.Add(entry.FormKey);
                    }
                }
            }

            public void Process()
            {
                // begin with COBJs
                var allCobjs = state.LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides();
                foreach (var cobj in allCobjs)
                {
                    try
                    {
                        ProcessCobj(cobj);
                    }
                    catch (Exception e)
                    {
                        throw RecordException.Enrich(e, cobj);
                    }
                }
            }

            private void ProcessCobj(IConstructibleObjectGetter cobj)
            {
                // try this. It seems that OMOD COBJs don't have these two
                if (!cobj.WorkbenchKeyword.IsNull || (cobj.Categories != null && cobj.Categories.Count > 0))
                {
                    return;
                }

                var craftResult = cobj.CreatedObject.TryResolve(state.LinkCache);

                var omod = (craftResult as IAObjectModificationGetter);

                if (omod == null || omod.LooseMod.IsNull)
                {
                    return;
                }

                var miscOmod = omod.LooseMod.TryResolve(state.LinkCache);
                if (null == miscOmod)
                {
                    return;
                }

                if (cobj.Components == null)
                {
                    return;
                }

                var scrapComponents = GetScrapComponents(cobj.Components);

                if (!scrapComponents.Any())
                {
                    return;
                }

                // otherwise, create an override for the misc
                var newMisc = state.PatchMod.MiscItems.GetOrAddAsOverride(miscOmod);
                newMisc.Components ??= new();
                if (newMisc.Components.Count > 0)
                {
                    newMisc.Components.Clear();
                }

                foreach (var pair in scrapComponents)
                {
                    MiscItemComponent foo = new()
                    {
                        Component = pair.Item1,
                        Count = pair.Item2
                    };
                    newMisc.Components.Add(foo);
                }
            }

            private IEnumerable<Tuple<IFormLink<IComponentGetter>, uint>> GetScrapComponents(IReadOnlyList<IConstructibleObjectComponentGetter> compList)
            {
                var result = new List<Tuple<IFormLink<IComponentGetter>, uint>>();
                foreach (var entry in compList)
                {
                    // do this check before resolving
                    var componentFormKey = entry.Component.FormKey;
                    if (blackList.Contains(componentFormKey))
                    {
                        continue;
                    }
                    double num = entry.Count;
                    if (num <= 0)
                    {
                        continue;
                    }


                    num = settings.componentLossFactor * num;

                    switch (settings.roundMode)
                    {
                        case RoundingMode.Up:
                            num = Math.Ceiling(num);
                            break;
                        case RoundingMode.Down:
                            num = Math.Floor(num);
                            break;
                        case RoundingMode.Normal:
                            num = Math.Round(num);
                            break;
                    }

                    if (num <= 0)
                    {
                        continue;
                    }
                    uint numInt = (uint)num;

                    // now do the resolve
                    var comp = entry.Component.TryResolve(state.LinkCache);

                    // is this a component?
                    if (comp is not IComponentGetter)
                    {
                        continue;
                    }

                    var compLink = comp.ToLink<IComponentGetter>();
                    result.Add(new Tuple<IFormLink<IComponentGetter>, uint>(compLink, numInt));
                }

                return result;
            }
        }
    }
}
